"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/// <reference path="../../typings/webAssemblyCommon.d.ts" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wasm = exports.Filetype = exports.OpenFlags = exports.PseudoterminalState = void 0;
const vscode_1 = require("vscode");
const version_1 = __importDefault(require("./version"));
const semverParse = require("semver/functions/parse");
const semverSatisfies = require("semver/functions/satisfies");
var PseudoterminalState;
(function (PseudoterminalState) {
    /**
     * The pseudoterminal is not in use.
     */
    PseudoterminalState[PseudoterminalState["free"] = 1] = "free";
    /**
     *  The pseudoterminal is in use however no process is currently running.
     */
    PseudoterminalState[PseudoterminalState["idle"] = 2] = "idle";
    /**
     * The pseudoterminal is in use and a process is currently running.
     */
    PseudoterminalState[PseudoterminalState["busy"] = 3] = "busy";
})(PseudoterminalState = exports.PseudoterminalState || (exports.PseudoterminalState = {}));
/**
 * Flags used to open a file.
 */
var OpenFlags;
(function (OpenFlags) {
    /**
     * No flags.
     */
    OpenFlags.none = 0;
    /**
     * Create file if it does not exist.
     */
    OpenFlags.create = 1 << 0;
    /**
     * Fail if not a directory.
     */
    OpenFlags.directory = 1 << 1;
    /**
     * Fail if file already exists.
     */
    OpenFlags.exclusive = 1 << 2;
    /**
     * Truncate file to size 0.
     */
    OpenFlags.truncate = 1 << 3;
})(OpenFlags = exports.OpenFlags || (exports.OpenFlags = {}));
var Filetype;
(function (Filetype) {
    /**
     * The type of the file descriptor or file is unknown or is different from
     * any of the other types specified.
     */
    Filetype[Filetype["unknown"] = 0] = "unknown";
    /**
     * The file descriptor or file refers to a directory.
     */
    Filetype[Filetype["directory"] = 1] = "directory";
    /**
     * The file descriptor or file refers to a regular file.
     */
    Filetype[Filetype["regular_file"] = 2] = "regular_file";
    /**
     * The file descriptor or file refers to a character device.
     */
    Filetype[Filetype["character_device"] = 3] = "character_device";
})(Filetype = exports.Filetype || (exports.Filetype = {}));
var Wasm;
(function (Wasm) {
    let $api = undefined;
    let $promise = undefined;
    function isOdd(value) {
        return value % 2 === 1;
    }
    function api() {
        if ($api === null) {
            throw new Error(`Unable to activate WASM WASI Core extension`);
        }
        if ($api === undefined) {
            throw new Error(`Wasm API not yet loaded. Call await Wasm.load() first.`);
        }
        return $api;
    }
    Wasm.api = api;
    async function load() {
        if ($promise === null) {
            throw new Error(`Unable to activate WASM WASI Core extension`);
        }
        if ($promise !== undefined) {
            return $promise;
        }
        const wasiCoreExt = vscode_1.extensions.getExtension('ms-vscode.wasm-wasi-core');
        if (wasiCoreExt === undefined) {
            throw new Error(`Unable to load WASM WASI Core extension.`);
        }
        try {
            $promise = wasiCoreExt.activate();
            $promise.then((api) => {
                const extVersion = semverParse(api.version);
                if (extVersion === null) {
                    throw new Error(`Unable to parse WASM WASI Core extension version: ${api.version}`);
                }
                const moduleVersion = semverParse(version_1.default);
                if (moduleVersion === null) {
                    throw new Error(`Unable to parse WASM WASI Core module version: ${version_1.default}`);
                }
                const extIsPrerelease = isOdd(extVersion.major) || isOdd(extVersion.minor) || isOdd(extVersion.patch);
                if (moduleVersion.prerelease.length > 0) {
                    if (!extIsPrerelease) {
                        throw new Error(`WASM WASI Core extension version ${api.version} is a pre-release version but the module version ${version_1.default} is not.`);
                    }
                    if (moduleVersion.prerelease[0] !== 'pre' || moduleVersion.prerelease[1] !== 1) {
                        throw new Error(`WASM WASI Core extension version ${api.version} is a pre-release version but the module version ${version_1.default} is not a valid pre-release version`);
                    }
                    moduleVersion.prerelease = [];
                }
                if (!semverSatisfies(api.version, `^${moduleVersion.format()}`)) {
                    throw new Error(`WASM WASI Core module version ${version_1.default} is not compatible with extension version ${api.version}`);
                }
                $api = api;
            }, () => {
                $api = null;
            });
            return $promise;
        }
        catch (err) {
            $promise = null;
            throw new Error(`Unable to activate WASM WASI Core extension: ${err}`);
        }
    }
    Wasm.load = load;
})(Wasm = exports.Wasm || (exports.Wasm = {}));
